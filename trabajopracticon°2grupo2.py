# -*- coding: utf-8 -*-
"""TrabajoPracticoN°2Grupo2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1y4eEsGj7GPcdULvmog4P6wdbFnr4pXok

# **Introducción**

En este trabajo práctico vamos a integrar los temas de la primer parte de la materia, centrándonos en las estructuras de datos Pila (Stack) y Cola (Queue). Van a tener que utilizar los conocimientos que fueron adquiriendo hasta ahora, para resolver un problema e implementar esta solución en el lenguaje de programación Python. No se pide modelar este ejercicio usando objetos. No se compliquen buscando herencias y clases abstractas. No está mal si necesitan poner un if  en algunos métodos donde normalmente tratarían de usar herencia y polimorsmo.


**1.1. Presentación del problema**

En una biblioteca deciden informatizar el manejo de la salida y entrada de libros mediante el sistema de préstamo. Para esto contratan a une estudiante de la UNAHUR para que modele el problema y diseñe e implemente una solución que le permita automatizar el proceso.
Durante este trabajo van a implementar tipos de datos y operaciones para trabajar con los prestamos de libros a los usuarios. Para resolver el problema de organización de la biblioteca, vamos a modelar los **libros**, las **estanterías** y finalmente los **escritorios de atención** de la biblioteca. Cada escritorio de atención tiene un depósito con varias estanterías con libros. Para el modelado de los libros, se deben tener en cuenta estas condiciones:


> • Cada libro se identica con un código (3 letras y 5 números).

>  • Los libros pueden ser de 3 géneros: *Teatro, Poesía o Narración.* 

>  • Cada libro tiene dos tipos: *Nacional o Internacional.* Según la nacionalidad del autor/autora.


#**Objetivos**

**2.1. Estanterías**

Denir un TDA que represente a una estantería en la que se guardan los libros en la biblioteca. Cada estantería se modela con 2 pilas de libros, una de libros de autores Nacionales y otra de libros de autores internacionales. Estas pilas se van modicando a medida que se prestan y se
devuelven libros. Cada estantería se identica con un número (entre 0 y 999). Las estanterías tienen una cantidad crítica de libros para cada pila (por defecto 50 libros). El TDA **Estanteria** debe incluir las siguientes operaciones:

**_guardarLibro(libro):_** Agrega el libro que recibe por parámetro a la pila que corresponde a su tipo. Si se excede la cantidad **crítica** en alguna pila, se almacena el libro pero se debe informar por pantalla la situación.

**_primerLibroDisponible():_** Retorna el primer libro disponible en la estantería. Si hay libros Nacionales, devuelve el primer libro a extraer de la pila correspondiente, caso contrario, el primer libro a extraer de la pila de Internacionales. No desapila el libro, solo lo muestra.

**_libroParaRecomendar(generoDeLibro):_** Recibe por parámetro un género literario y desapila y retorna el primer libro de ese género que se puede prestar. Los libros de autores Nacionales se recomiendan primero, si en la pila de Nacionales no hay ningún libro de ese género, se recomiendan los de autores Internacionales.

**_buscarLibro(codigoLibro):_** Recibe un código de libro (codigoLibro) y si en alguna de las pilas (cualquiera de las dos) está ese libro, lo retorna. El libro no debe ser elimimado de la pila.

**_prestarLibro(codigoLibro):_** Recibe un código de libro (codigoLibro) y si el libro se encuentra en alguna de las pilas de la estanteía lo elimina de ella y lo retorna.

**_librosPorTipo():_** Cuenta la cantidad de libros de cada tipo (Nacional e Inernacional por separado) y retorna los dos valores.

**_cantidadTotalLibros():_** Retorna la cantidad total de libros en la estantería, sumando los de las dos pilas.

**_esCritica():_** Retorna True si alguna de las dos pilas tiene una cantidad de libros mayor que la cantidad crítica o False en caso contrario.

**_librosPorGenero(generoLibro):_** Retorna la cantidad total de libros (de cualquier tipo) que son del género que se recibe por parámetro (Teatro, Poesía o Narración).


**Aclaración:** Pueden usar los TDAs Pila (Stack) y Cola (Queue) que programaron en las guías de ejercicios correspondientes.


#**2.2. Escritorio de atención**

Denir un TDA que represente a un escritorio donde les usuaries piden y devuelven los libros. El escritorio tiene un depósito para los libros, en este depósito hay estanterías que se distribuyen en forma de las y columnas, es decir, en el depósito tenemos M las con N estanterías cada una. Modelar con un TDA el Escritorio de atención, teniendo en cuenta que puede haber lugares del depósito donde no hay una estantería, cuando un lugar esta vacío, se representa como None en la estructura. Implementar las siguientes operaciones para el TDA del EscritorioDeAtención:

**_establecerEstanteria(nroFila, nroColumna, estanteria)_:** Pone la estantería en la ubicación correspondiente.

**_cantidadDeEstanteriasCriticas(nroFila):_** Operación recursiva que retorna la cantidad de estanterías en situación crítica en la la que recibe por parámetro.

**_estanteríaMenosRecargada():_** Retorna la ubicación (número de la y número de columna) de la estantería que tiene el menor número de libros de tipo Nacional en todo el depósito.

**_buscaEstanteria(nroEstanteria):_** Recibe el número de estantería y retorna la ubicación de la estantería en el depósito (número de la y número de columna).

**_guardarLibros(colaDelibros):_** Operación que recibe como entrada una cola de libros y los debe guardar de a uno en la estantería menos recargada del depósito. Notar que la estantería menos recargada del depósito puede ir variando a medida que se van mandando los libros de la cola.

**_sacarLibros(colaDelibros):_** Operación que recibe como entrada una cola con códigos de libros y los debe buscar y sacar de las estanterías del depósito. La operación debe retornar una pila con todos los libros que se sacaron. Notar que algunos libros pueden no estar en el depósito.

**_moverLibro(codigoLibro, nroEstanteriaOrigen, nroEstanteriaDestino):_** Saca el libro con código codigoLibro de la estantería nroEstanteriaOrigen y lo pasa a la estantería de nroEstanteriaDestino.


#**3. Datos de prueba**

Previo a la entrega del trabajo práctico, deben controlar que su implementación funcione con un lote de datos de prueba que nosotros les vamos a entregar. El lunes 24 de mayo, subiremos al webcampus el lote de datos de prueba, junto con un programa en Python para ejecutarlo. Por
favor, respetar los nombres de las operaciones y de los TDAs (Libro, Estanteria y Escritorio-DeAtencion).


#**Entrega**
La entrega del trabajo práctico debe ser:

Un informe escrito (doc, pdf. etc), incluyendo:

>• Descripción de cada una de las estructuras de datos diseñadas e implementadas.

>• Incluir una descripción escrita de los algoritmos. Pueden incluir diagramas de flujo.

>• Descripción de la implementación en Python. Explicar claramente que hace cada función y procedimiento implementados.

>• Código completo y comentado de la implementación.

>• Opcional: Video explicando cómo funciona el algoritmo.

Luego de la entrega, les vamos a hacer preguntas a las/los integrantes del grupo sobre el trabajo, asi que les aconsejamos no copiar código que encuentren en internet.

#**Link del enunciado**

https://drive.google.com/file/d/1PDtFuPW4GRg_BjL-NIIEggGpqM4eeqkw/view

# **Script implementador:**
https://colab.research.google.com/drive/1gSFuDyTPUrVkUA14YN0tqtLATh6j6sW5?usp=sharing
"""

#from TP_pilas_y_colas_2021 import *
################################################################################
###########################SCRIPT DE PRUEBA#####################################
################################################################################

#############################IMPORTANTE!!!!!!###################################
#############COSAS PARA CONTROLAR ANTES DE EJECUTAR ESTA PRUEBA#################
#############################IMPORTANTE!!!!!!###################################

#Si usan Enums, los tienen que definir asi (respetar nombres y numeros asociados a cada uno):
#class GeneroLibro(int,Enum):
#  Teatro = 0
#  Poesia = 1
#  Narracion = 2
#class TipoLibro(int,Enum):
#  Nacional = 0
#  Internacional = 1

#En la parte donde se cargan los datos de las Estanterías: Comenten o descomenten los
#bloques de codigo indicados, segun usen o no usen Enums en sus implementaciones

#Orden de variables en constructores (__init__):
#TDA Libro: self, codigo, genero, tipo
#TDA Estanteria: self, numero, cantCritica
#TDA EscritorioDeAtencion: self, cantFilas, cantColumnas

#Mantengan nombres de TDAs, operaciones y orden de parametros en las operaciones
#segun lo que esta definido en el enunciado

#Para ver mejor la salida pueden comentar la parte que imprime cuando la Estanteria 
#llega a la cantidad critica en la operacion guardarLibro

########################Definicion de variables#################################
#################IMPORTANTE: NO MODIFICAR ESTAS VARIABLES!!!!!!!!!!!!!!!!!!!!!!!
nroFilas = 10
nroColumnas = 10
generos = ["Teatro","Poesia","Narracion"]
tipos = ["Nacional","Internacional"]
estanteriasData = {}
primerosLibrosPorEstanteria = {}
primerosLibrosDeNarracion = {}

################################################################################
###########Creacion de escritorio y carga de estanterias########################
################################################################################

####################Lectura de archivo con datos de libros######################
librosFile = open('TP_pilasColas_datosPrueba_2021.csv')
for libro in librosFile:
  libroData = libro[:-1].split(',')
  numero = int(libroData[0])
  if numero in estanteriasData:
    estanteriasData[numero][1].append(libroData[4:7])
  else:
    estanteriasData[numero] = []
    estanteriasData[numero].append(libroData[1:4])
    estanteriasData[numero].append([libroData[4:7]])
librosFile.close() 

################################################################################

######################Creacion de escritorio####################################
escritorioDeAtencion = EscritorioDeAtencion(nroFilas, nroColumnas)
################################################################################

######################Carga de estanterias######################################
for numero in estanteriasData:
  estanteriaData = estanteriasData[numero][0]
  cantCritica = int(estanteriaData[0])
  nroFila = int(estanteriaData[1])
  nroColumna = int(estanteriaData[2])

  ############Creacion de estanteria################
  estanteria = Estanteria(numero, cantCritica)
  
  ############Carga de libros a estanteria########
  for libroData in estanteriasData[numero][1]:
    codigo = libroData[0]
    
    ###################Para uso con Enum########################################
    genero = GeneroLibro(generos.index(libroData[2]))                           ###Comentar si usan strings 
    tipo = TipoLibro(tipos.index(libroData[1]))                                 ###Comentar si usan strings
    ############################################################################

    ###################Para uso con strings#####################################
    #genero = libroData[2]                                                      ###Comentar si usan Enums
    #tipo = libroData[1]                                                         ###Comentar si usan Enums
    ############################################################################

    ##############Creacion de libro#########################
    libro = Libro(codigo, genero, tipo)                                         ###Comentar si usan TDA para codigo
    #libro = Libro(CodigoLibro(codigo[0:3],codigo[3:8]), genero, tipo)          ###Comentar si usan string para codigo
    ##############Guardo libro en estanteria##################
    estanteria.guardarLibro(libro)
  
  ################Ubicacion de estanteria en deposito####################
  escritorioDeAtencion.establecerEstanteria(nroFila, nroColumna, estanteria)
  print(estanteria)
  print(estanteria.pilaDeAutoresNacionales)


  ##############################################################################
  ##########Ejecucion de pruebas de operaciones de TDA Estanteria###############
  ##############################################################################

  ##########################primerLibroDisponible###############################
  primerosLibrosPorEstanteria[numero] = estanteria.primerLibroDisponible()

  ##########################libroParaRecomendar#################################
  #####################Para uso con Enum########################################
  libroARecomendar = estanteria.libroParaRecomendar(GeneroLibro(generos.index("Narracion")))  ###Comentar si usan strings
  ##############################################################################

  #####################Para uso con strings#####################################
  #libroARecomendar = estanteria.libroParaRecomendar("Narracion")                                 ###Comentar si usan Enums
  ##############################################################################

  primerosLibrosDeNarracion[numero] = libroARecomendar
  estanteria.guardarLibro(libroARecomendar)
################################################################################

#####################Impresion de escritorio de atencion########################
print("Depósito de estanterías de escritorio de atención:\n")
print(escritorioDeAtencion)
print("-----------------------------------------------------------------------\n")

################################################################################
############Impresion de pruebas de operaciones de TDA Estanteria###############
################################################################################

for numero in primerosLibrosPorEstanteria:
  ##########################primerAuxilioAEnviar################################
  print("Primer libro disponible en estanteria", numero, ":", primerosLibrosPorEstanteria[numero])
  
  ##########################libroParaRecomendar#################################
  print("Libro de género Narracion para recomendar en estanteria", numero, ":", primerosLibrosDeNarracion[numero])

print("-----------------------------------------------------------------------\n")
  
################################################################################
#############Prueba de operaciones de TDA EscritorioDeAtencion##################
################################################################################

#######################cantidadDeEstanteriasCriticas###############################
print("\n\nCantidad de estanterias criticas en cada fila del depósito:\n")
for nroFila in range(nroFilas):
  print("Fila",nroFila,":",escritorioDeAtencion.cantidadDeEstanteriasCriticas(nroFila))  
print("-----------------------------------------------------------------------")

#########################estanteriaMenosRecargada###############################
print("\n\nEstantería menos recargada del depósito:\n")
print(escritorioDeAtencion.estanteriaMenosRecargada())  
print("-----------------------------------------------------------------------")
#########################buscaEstanteria########################################
print("\n\nUbicación de cada estantería en el depósito:\n")
for numero in estanteriasData:
  print("Número",numero,":",escritorioDeAtencion.buscaEstanteria(numero))  
print("-----------------------------------------------------------------------")

##########################moverLibro############################################
print("\n\nMovimiento de libros de la estantería 104 (fila 5) a la estantería 103 (fila 1):\n")
print("Cantidad de estanterías criticas en la fila 1 antes:",escritorioDeAtencion.cantidadDeEstanteriasCriticas(1))
print("Cantidad de estanterías criticas en la fila 5 antes:",escritorioDeAtencion.cantidadDeEstanteriasCriticas(5))

for libroData in estanteriasData[104][1]:
  codigo = libroData[0]
  escritorioDeAtencion.moverLibro(codigo,104,103)                               ###Comentar si usan TDA para codigo
  #escritorioDeAtencion.moverLibro(CodigoLibro(codigo[0:3],codigo[3:8]),104,103) ###Comentar si usan string para codigo

print("\nCantidad de estanterías criticas en la fila 1 despues:",escritorioDeAtencion.cantidadDeEstanteriasCriticas(1))
print("Cantidad de estanterías criticas en la fila 5 despues:",escritorioDeAtencion.cantidadDeEstanteriasCriticas(5))
print("-----------------------------------------------------------------------")

"""# **TDA Pila:**"""

# TDA
class Pila:
  def __init__(self,entrada = None):                         # Constructor
    self.pila = []
    if entrada:
      for dato in entrada:
        self.pila.append(dato)
  
  def __repr__(self):
    return str(self.pila)

  def vaciar(self):                                          # Vacia la pila
    self.pila.clear()

  def estaVacia(self):
    return len(self.pila) == 0                               # Pila vacia

  def apilar(self, item):                                    # Suma un item a la pila
    self.pila.append(item)

  def desapilar(self):                                       # Retira el ultimo elemento de la pila (si hay)
    dato = None
    if not self.estaVacia():
      dato = self.pila.pop()
    return dato

  def primerElemento(self):                                  # Devuelve el primer elemento de la pila (si hay)
    if self.estaVacia():
      print("La lista se encuentra vacia.")
      return None
    return self.pila[-1]

  def clonar(self):                                         # Devuelve una copia de la pila
    pilaClon = Pila()
    for elemento in self.pila:
      pilaClon.pila.append(elemento) 
    return pilaClon

  def tamano(self):                                          # Devuelve el tamaño de la pila
    return len(self.pila)

  def estaVacia(self):                                       # Devuelve TRUE si la pila se encuentra vacia
    return len(self.pila) == 0

  # Funciones Auxiliares
  def invertirPila(self):
    pilaAux = self.clonar()
    self.vaciar()
    while not pilaAux.estaVacia():
      self.apilar(pilaAux.desapilar())

"""# **TDA Cola:**"""

# TDA
class Cola:
  def __init__(self,entrada = None):                         # Constructor
    self.cola = []
    if entrada:
      for dato in entrada:
        self.cola.append(dato)
  
  def __repr__(self):
    return str(self.cola)

  def vaciar(self):                                          # Vacia la cola
    self.cola.clear()

  def estaVacia(self):
    return len(self.cola) == 0                               # Cola vacia

  def encolar(self, item):                                   # Encola un item a la cola
    self.cola.insert(0,item)

  def desencolar(self):                                      # Retira el ultimo elemento de la cola (si hay)
    dato = None
    if not self.estaVacia():
      dato = self.cola.pop()
    return dato

  def primerElemento(self):                                  # Devuelve el primer elemento de la cola (si hay)
    dato = None
    if not self.estaVacia():
      dato = self.cola[len(self.cola)-1]                     ####return self.cola[-1]
    return dato

  def clonar(self):                                          # Devuelve una copia de la cola
    colaClon = Cola()
    for elemento in self.cola:
      colaClon.cola.append(elemento)  
    return colaClon

  def tamano(self):                                          # Devuelve el tamaño de la cola
    return len(self.cola)

  def estaVacia(self):                                       # Devuelve TRUE si la cola se encuentra vacia
    return len(self.cola) == 0

  def moverElPrimeroAlFinal(self):
    self.encolar(self.desencolar())

"""
#**TDA DE LIBRO**
"""

from enum import Enum

class GeneroLibro(int,Enum):
  Teatro = 0
  Poesia = 1
  Narracion = 2

class TipoLibro(int,Enum): #reemplazar tanto en el codigo como en el script
  Nacional = 0
  Internacional = 1
  

#Se encarga de validar si el codigo de identificacion ingresado
#es valido para un libro
def validaCodigoDeIdentificacion(ID):
  if not (len(ID) == 8 and ID[0:3].isalpha() and ID[3:].isnumeric()):
    raise Exception ("ID incorrecto")
  else:
    return ID

#Se encarga de validar si el genero ingresado 
#pertenece a los generos existentes 
def validaGenero(genero):
  if not isinstance(GeneroLibro(genero) , GeneroLibro):
      raise Exception("Genero incorrecto")
  else:
    return genero

#Se encarga de validar si la nacionalidad de libro ingresado 
#pertenece a los tipos existentes
def validaTipo(tipo):
  if not isinstance(TipoLibro(tipo) , TipoLibro):
      raise Exception("Tipo incorrecto")
  else:
    return tipo



# TDA
class Libro:
  #constructor del TDA Libro, que recibe como parametro un codigo de identificacion,
  #un genero y un tipo (de nacionalidad)
  def __init__(self,codigoDeIdentificacion,genero,tipo):
    self.codigoDeIdentificacion = validaCodigoDeIdentificacion(codigoDeIdentificacion)
    self.generos = validaGenero(genero)
    self.tipo = validaTipo(tipo)
  
  #se encarga de definir como deberia mostrarse el TDA a la hora de ser imprimido
  def __repr__(self):                                        
    return "Cod_Identificacion:" + " " + str(self.codigoDeIdentificacion) + ", " + "Genero:" + " " + str(GeneroLibro(self.generos).name) + ", " + "Nacionalidad:" + " " + str(TipoLibro(self.tipo).name)

  def esNacional(self):
    return self.tipo == 0

  def generoDelLibro(self):
    return self.generos

  def nacionalidadDelLibro(self):
    return  self.tipo

  def codigoDelLibro(self):
    return self.codigoDeIdentificacion

"""# **TDA Estanterias**"""

def validaNumID(idDeEstanteria):
  if 0 < idDeEstanteria < 999:
    return idDeEstanteria
  else:
    raise Exception("El ID ingresado excede los limites.")

def recomendarLibro(pila,generoDeLibro):
    libroARecomendar = None
    aux = pila.clonar()
    aux2 = pila.clonar()
    aux2.invertirPila()
    pila.vaciar()
    if not aux.estaVacia() :
      while not aux.estaVacia() and libroARecomendar == None :                  
        primerElemento = aux.primerElemento()    
        if primerElemento.generoDelLibro() == generoDeLibro:       
          libroARecomendar = aux.primerElemento()
        aux.desapilar()
    
    while not aux2.estaVacia():
      libroAPoner = aux2.desapilar()
      if libroAPoner != libroARecomendar:
        pila.apilar(libroAPoner)

    return libroARecomendar    

def prestarLibroPorPila(pila,codigoLibro):
    libroParaMostrar = None
    aux = pila.clonar()
    aux.invertirPila() #se invierte para apilar en el orden correcto
    pila.vaciar()
    
    while not aux.estaVacia():
      if aux.primerElemento().codigoDelLibro() != codigoLibro:
        pila.apilar(aux.desapilar())        # en el caso de que el codigo buscando es distinto al codigo del primer elemento se desapila del 
      else:                                                                   # la pila auxiliar y se inserta en la pila de nacionales  
        libroParaMostrar = aux.desapilar()                          # caso contrario se guarda el libro y se termina de apilar en la pila de autores nacionales
        while not aux.estaVacia():
          pila.apilar(aux.desapilar())
    return libroParaMostrar


def buscarLibroPorPila(pila,codigoLibro):
    libroBuscado = None
    aux = pila.clonar()
    while not aux.estaVacia() and libroBuscado == None:                  
      libro = aux.desapilar()                   
      if libro.codigoDelLibro() == codigoLibro: 
          libroBuscado = libro
    return libroBuscado      

def librosPorGeneroEnPila(pila,generoLibro):
    totalLibrosPorGenero = 0
    aux = pila.clonar()
    
    while not aux.estaVacia():
      elemento = aux.desapilar()
      if elemento.generoDelLibro() == generoLibro:          
         totalLibrosPorGenero += 1
    return totalLibrosPorGenero

# TDA
class Estanteria: 
  # Constructor
  def __init__(self,numID = int,cantCritica = 50):
    self.pilaDeAutoresNacionales = Pila()
    self.pilaDeAutoresInternacionales = Pila()   
    self.numID = validaNumID(numID)
    self.cantCritica = cantCritica # Por defecto 50
                          
  #se encarga de definir como deberia mostrarse el TDA a la hora de ser imprimido
  def __repr__(self):
    return "Numero de ID:" + " " + str(self.numID) +"; "+" cantidad critica de estante: "+" "+ str(self.cantCritica)+ "; "+ "Cantidad de libros de autores nacionales:" + " " + str(self.tamanoDePilaDeAutoresNacionales()) +" "+ "Cantidad de libros de autores internacionales:" + " " + str(self.tamanoDePilaDeAutoresInternacionales()) + " " +"es una estanteria critica?" + " " + str(self.esCritica())

  #esta funcion devuelve el id del estante
  def numeroId(self):
    return self.numID
  
  ##se encarga de comprobar si el id pasado es igual al del estante 
  def esNumID(self,nroId):
    return self.numeroId() == nroId
  
  #esta funcion se encarga de guardar el libro que reciba por parametro
  #en una de las dos pilas del TDA dependiendo de la nacionalidad de libro
  def guardarLibro(self,libro):
    if libro.esNacional() and not self.nacionalesEsCritica(): 
      self.pilaDeAutoresNacionales.apilar(libro)
    elif libro.esNacional() and self.nacionalesEsCritica():
      self.pilaDeAutoresNacionales.apilar(libro)
      #print("Se ha alcanzado la cantidad critica en la estanteria.")

    elif not libro.esNacional() and not self.internacionalesEsCritica():
      self.pilaDeAutoresInternacionales.apilar(libro)
    elif not libro.esNacional() and  self.internacionalesEsCritica():
      self.pilaDeAutoresInternacionales.apilar(libro)
      #print("Se ha alcanzado la cantidad critica en la estanteria.")
  
  #esta funcion retorna las 2 pilas de autores que contiene el estante
  def pilasDeAutores(self):
    return self.pilaDeAutoresNacionales, self.pilaDeAutoresInternacionales
  
  #esta funcion se encarga de retornar el primer libro disponible de la estanteria  
  def primerLibroDisponible(self):
    primerElemento = None
    if not self.pilaDeAutoresNacionales.estaVacia():
      primerElemento = self.pilaDeAutoresNacionales.primerElemento()
    elif not self.pilaDeAutoresInternacionales.estaVacia():
       primerElemento = self.pilaDeAutoresInternacionales.primerElemento()
    return primerElemento   

  #esta funcion se encarga de devolver el primer libro que encuentre con el genero que se pase por parametro,
  #primero busca en la pila de autores nacionales y luego en la pila de autores internacionales
  def libroParaRecomendar(self,generoDeLibro):
    #libroARecomendar = None  
    libroARecomendar = recomendarLibro(self.pilaDeAutoresNacionales,generoDeLibro)

    if libroARecomendar == None:
      libroARecomendar = recomendarLibro(self.pilaDeAutoresInternacionales,generoDeLibro)
    if libroARecomendar == None:
      raise Exception("No hay un libro que se pueda recomendar en estos momentos.")
    
    return libroARecomendar

  #esta funcion se encarga de buscar un libro y devolverlo, a partir del codigo del libro pasado por parametro
  def buscarLibro(self,codigoLibro):
    libroBuscado = None
    libroBuscado = buscarLibroPorPila(self.pilaDeAutoresNacionales,codigoLibro)
    if libroBuscado == None:
      libroBuscado = buscarLibroPorPila(self.pilaDeAutoresInternacionales,codigoLibro)
    if libroBuscado == None:
      raise Exception("no se encontro el libro")
    return libroBuscado

  #esta funcion se encarga de retornar un libro, el cual se busca mediante el
  #codigo pasado por parametro, y lo remueve de la pila donde se encuentre
  def prestarLibro(self,codigoLibro):  
    libroParaMostrar = None
    
    libroParaMostrar = prestarLibroPorPila(self.pilaDeAutoresNacionales,codigoLibro)

    if libroParaMostrar == None:

      libroParaMostrar = prestarLibroPorPila(self.pilaDeAutoresInternacionales,codigoLibro)
    
    if libroParaMostrar == None:
      raise Exception("no hay un libro para prestar del genero deseado")
    return libroParaMostrar
  
  #esta funcion se encarga de devolver el mañano de las pilas de autores nacionales e internacionales 
  def librosPorTipo(self):
    return self.tamanoDePilaDeAutoresNacionales(),self.tamanoDePilaDeAutoresInternacionales()
  
  #esta funcion se encarga de devolver la cantidad total de libros que tiene el estante
  def cantidadTotalLibros(self):
    return self.tamanoDePilaDeAutoresNacionales() + self.tamanoDePilaDeAutoresInternacionales()

  #esta funcion se encarga de saber si la pila de autores nacionales es critica, osea si supera la cantidad critica de libros
  def nacionalesEsCritica(self):
    return self.pilaDeAutoresNacionales.tamano() > self.cantCritica
  
  #esta funcion se encarga de saber si la pila de autores internacionales es critica, osea si supera la cantidad critica de libros
  def internacionalesEsCritica(self):
    return self.pilaDeAutoresInternacionales.tamano() > self.cantCritica

  #esta funcion se encarga de saber si alguna de las pilas de autores supero la cantidad critica de libros
  def esCritica(self):
    return self.internacionalesEsCritica() or self.nacionalesEsCritica()

  #esta funcion se encarga de retornar una pila con los libros en el estante
  #que pertenezcan al genero pasado por parametro  
  def librosPorGenero(self,generoLibro):
    totalLibrosPorGenero = 0
    totalLibrosPorGenero += librosPorGeneroEnPila(self.pilaDeAutoresNacionales,generoLibro) + librosPorGeneroEnPila(self.pilaDeAutoresInternacionales,generoLibro)
    return totalLibrosPorGenero
  
  #esta funcion se encarga de retornar el tamanio de la pila
  #de autores nacionales
  def tamanoDePilaDeAutoresNacionales(self):
    return self.pilaDeAutoresNacionales.tamano()

  #esta funcion se encarga de retornar el tamanio de la pila
  #de autores internacionales
  def tamanoDePilaDeAutoresInternacionales(self):
    return self.pilaDeAutoresInternacionales.tamano()

"""#**TDA Escritorio de Atencion:**"""

import numpy as np
 
class EscritorioDeAtencion: 
  
  #constructor del escritorio de atencion
  def __init__(self,nroFilas,nroColumnas):
    self.nroFilas = nroFilas
    self.nroColumnas = nroColumnas
    self.deposito = np.full((self.nroFilas,self.nroColumnas), None)

  #se encarga de definir como se vera el escritorio cuando se quiere imprimir 
  def __repr__(self):
    return "Escritorio de atencion:" + " " + str(self.deposito)
  
  #esta funcion se encarga de establecer la estanteria pasada por parametro
  #en la fila y columna(pasadas tambien por parametro) deseadas en el deposito
  def establecerEstanteria(self,nroFila, nroColumna, estanteria):
    self.deposito[nroFila][nroColumna] = estanteria 
  
  #esta funcion se encarga de contar las cantidad de estanterias criticas que hay en la fila, pasada por parametro, en el deposito.
  def cantidadDeEstanteriasCriticas(self, nroFila, n=0):
    if n == (self.nroColumnas - 1):
      if self.deposito[nroFila][n] != None and self.deposito[nroFila][n].esCritica():  #en el caso que este en la posicion final de la fila
        cantidadCritica = 1
      else:
        cantidadCritica = 0        
    elif self.deposito[nroFila][n] != None and self.deposito[nroFila][n].esCritica(): #en el caso de que no este en la posicion final de la fila
      cantidadCritica = 1 + self.cantidadDeEstanteriasCriticas(nroFila, n+1)
    else:
      cantidadCritica = 0 + self.cantidadDeEstanteriasCriticas(nroFila, n+1) 
      
    return cantidadCritica
  
  #esta funcion se encarga de retornar la estanteria menos cargada que hay en el deposito
  #def estanteriaMenosRecargada(self):
    #ubicacion = None
    #for fila in range(self.nroFilas):           # ---------------------------------------------
      #for columna in range(self.nroColumnas):   # --- Con esto se recorre el deposito---
          #estante = self.deposito[fila][columna]
          #if estante != None:
            #estMenNac = estante.tamanoDePilaDeAutoresNacionales()
            #if estante != None and estante.tamanoDePilaDeAutoresNacionales() < estMenNac:
              #estMenNac = estante.tamanoDePilaDeAutoresNacionales()  # Se actualiza el valor maximo de pila de autor nacional encontrado
              #ubicacion = fila,columna                               
    
    #return ubicacion 
 

  ###
  def estanteriaMenosRecargada(self):
    fila = 0
    columna = 0
    lista1 = []
    for i in range(self.nroFilas):
      for j in range(i, self.nroColumnas):
        if self.deposito[i][j] != None:
          lista1.append(self.deposito[i][j])
    
    lista1.sort(key=lambda x: x.tamanoDePilaDeAutoresNacionales())
    fila,columna = self.buscaEstanteria(lista1[0].numeroId())
    return fila,columna

  #esta funcion se encarga de buscar una estanteria a traves de su nro de estanteria pasado por parametro
  #y devuelve su fila y columna
  def buscaEstanteria(self,nroEstanteria):
    ubicacion = None
    for fila in range(self.nroFilas):           
      for columna in range(self.nroColumnas):   # --- Con esto se recorre deposito---
        estante = self.deposito[fila][columna]
        if estante != None and estante.esNumID(nroEstanteria):      # --- estante.numID 
          ubicacion = fila,columna
    
    if ubicacion == None:
      raise Exception("no se encuentró la estanteria buscada")
    
    return ubicacion
 
  #esta funcion se encarga de guardar la cola de libros pasada 
  #por parametro en la estanteria menos recargada
  def guardarLibros(self, colaDeLibros):
    while not colaDeLibros.estaVacia():
      fila,columna = self.estanteríaMenosRecargada()
      estanteAPoner = self.deposito[fila][columna]
      estanteAPoner.guardarLibro(colaDeLibros.desencolar()) # a medida que se desencola la cola de libros se guardan los libros en la estanteria
 
  #esta funcion se encarga de eliminar los libros (que se pasan por parametro en una cola de libros) del deposito
  def sacarLibros(self,colaDelibros):
    pilaRetorno = Pila()
    for fila in range(self.nroFilas):           
      for columna in range(self.nroColumnas):
        if self.deposito[fila][columna] != None:  #en el caso que no sea None, habra un estante
          estante = self.deposito[fila][columna] 
          colaAux = colaDelibros.clonar()         #se clona en el caso que se tenga que seguir buscando en el resto del deposito
          while not colaAux.estaVacia():
            codigo = colaAux.desencolar()
            libro = estante.buscarLibro(codigo)    
            if libro!= None:                       #si el libro se encuentra en la estanteria
              libroAPrestar = estante.prestarLibro(codigo)
              pilaRetorno.apilar(libroAPrestar)    #se apila en la pila de retorno
    return pilaRetorno          
  
 
  # Esta funcion se encarga de mover un libro
  def moverLibro(self, codigoLibro, nroEstanteriaOrigen, nroEstanteriaDestino):
      filaOrigen,columnaOrigen = self.buscaEstanteria(nroEstanteriaOrigen)
      estanteriaOrigen = self.deposito[filaOrigen][columnaOrigen]    
      libro = estanteriaOrigen.buscarLibro(codigoLibro)
      if libro != None:                                                         #en el caso de que exista el libro
         libroAMover = estanteriaOrigen.prestarLibro(codigoLibro)               
         filaDestino,columnaDestino = self.buscaEstanteria(nroEstanteriaDestino)
         estanteriaDestino = self.deposito[filaDestino][columnaDestino].guardarLibro(libroAMover)
      else:
        raise Exception("es posible que no este el libro en el estante buscado")